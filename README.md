# 🍗 치킨집

## 📑 Description 

<br>

### 🥁 Preview
![](../Mar-29-2022 19-02-45.gif.sb-d9626bfd-nfLbkP.gif)

<br>

### 🎯 Purpose

- '우아한테크코스'에서 시행한 프로젝트를 가져와 `클린코드`와 `객체지향`을 연습하기 위해 만든 프로젝트입니다.

   <br>

   * `클린코드`를 위해서는 우테코의 피드백 내용을 적극 반영했습니다.
       + 기능 목록 구현을 재검토한다.
       + 발생할 수 있는 예외케이스에 대해 고민한다.
       + 하드 코딩하지 않는다.
       + 주석은 꼭 필요한 경우에만 남긴다.
       + 축약하지 마라.
       + 필드의 수를 줄이기 위해 노력해라.
       
   <br>

   * `객체지향` 연습을 위해서는 '소트웍스 앤솔러지'의 객체지향 체조 원칙을 참고했습니다.
       + 한 메소드에 오직 한 단계의 들여쓰기만 한다.
       + else 키워드를 쓰지 않는다.
       + 모든 원시값과 문자열을 포장한다.
       + 한 줄에 점을 하나만 찍는다.
       + 줄여쓰지 않는다.
       + 모든 entity를 작게 유지한다.
       + 2개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
       + 일급 컬렉션을 쓴다.
       + getter/setter/property를 쓰지 않는다.
       
<br>

### 🚀 Feature Requirements

- 치킨집 사장님이 사용하는 간단한 포스(POS) 프로그램을 구현한다.
    * **주문등록, 결제하기, 프로그램 종료 기능**을 가진다.
- 메뉴 기본 정보가 주어지며 메뉴 번호, 종류, 이름, 가격을 가진다.
- 테이블 기본 정보가 주어지며 테이블 번호를 가진다.
- 한 테이블에서 주문할 수 있는 한 메뉴의 최대 수량은 99개이다.
- 주문이 등록된 테이블은 결제가 이루어지기 전까지 테이블 목록에 별도로 표시한다.
- 주문 내역에 대한 계산을 할 때는 **결제 유형에 따라 할인율**이 달라진다.
    * 치킨 종류 메뉴의 수량 합이 **10개가 넘는 경우 10,000원씩 할인**된다.
        + e.g. 10개는 10,000원 할인, 20개는 20,000원 할인
    * **현금 결제는 10%가 할인**되며 **할인된 금액에서 한 번 더 할인**이 가능하다.
- 주문 혹은 결제가 불가능한 경우 그 이유를 보여 주고, 다시 주문 혹은 결제가 가능하도록 해야한다.
- 최종 결제 금액을 보여준다.

<br>

### 🏗 POS Project Architecture

![](../../../Downloads/Drawio/Projects/'.png)

조영호님의 도서인 **"객체지향의 사실과 오해", "오브젝트"** 를 읽고 이해한 바를 기반으로 작성하려 노력했습니다.  
먼저 기능 목록을 작성하며 주어진 문제를 이해하고, 문제를 해결하기 위해 **어떤 메시지**를 보낼 것인지 먼저 생각하며 설계했습니다.  
객체의 상태나 데이터 주도적인 설계를 우선적으로 하지 않고, 객체 간의 메시지 전달을 통한 **협력을 중점적**으로 설계했습니다.    

CommandProcessor 인터페이스를 통해 **다양한 객체가 역할을 통해 하나의 협력에 참여**할 수 있도록 추상화했습니다.  
또한 **프로그램의 특성을 고려**했을 때, 추후 변경이 발생하기 쉽다고 판단된 할인 정책을 DiscountPolicy라는 인터페이스로 분리해내어, 할인정책 변경 시에도 변경에 대해 유연하게 대처할 수 있도록 설계했습니다. 

<br>


**추가한 도메인**
- Order : 메뉴와 수량 정보로, 99마리 이상을 초과하는 주문 감지, 할인율 적용, 계산 등에 사용됩니다. 
- Money : 돈을 원시 값으로 쓰지 않기 위해 포장한 객체입니다.
- DiscountPolicy : 할인 정책을 나타내는 기능으로서 추후 변경 가능성이 있다고 판단하여 인터페이스를 사용했습니다.
- PaymentType : 결제 방법을 나타내며, 방법에 따라 할인율이 적용됩니다.
- PaymentManager : 결제를 총괄합니다.
- CommandProcessor : 어떤 행위를 할지 결정하며 동등한 "과정"으로 판단하여 인터페이스를 사용했습니다.
- Action : 입력 값에 따라 필요한 CommandProcessor를 실행합니다.
- PosProgram : 프로그램을 종료할 때까지 반복합니다.

<br>

**기술 스택**
- 자바 8
    * Lambda식을 코드를 간결함과, 가독성의 개선을 위해 사용했습니다.
    * 마찬가지로 간결함과 가독성의 개선, 간단한 파이프라이닝을 위해 Stream을 사용했습니다.
    
<br>

- Gradle
    * 눈에 띄는 차이점으로는 기존의 Ant, Maven과 같은 빌드 툴의 xml 형식이 아닌, Groovy라는 언어를 이용해 코드로서 설정정보를 구성한다는 것입니다.
    * 또한 다른 빌드 툴 대비, 다음과 같은 장점을 가지고 있습니다.
        + Incrementality - Gradle은 작업의 입출력을 추적하여 필요한 것만 실행하고 가능한 경우 변경된 파일만 처리하여 작업을 최소화한다.
        + Build Cache - 같은 기기에 동일한 입력이 있을 경우 Gradle 빌드 캐시의 결과를 재사용한다.
        + Gradle Daemon - 빌드 정보를 메모리에 올려 유지하는 수명이 긴 Daemon process를 사용한다.
    * 위와 같은 장점들을 가지고 있어 개발자가 코드에 더 집중할 수 있는 환경을 제공해준다고 생각해 gradle을 사용했습니다.
    * 아래(좌: Gradle, 우: Maven)는 gradle에서 제공한 "Gradle vs Maven performance comparison"으로 gradle이 maven 대비 약 100배까지도 빠른 빌드를 제공합다고 합니다. 
![](../Apr-01-2022 19-31-23.gif)
    
<br>

- JUnit 5  
  ![](../../../Downloads/Drawio/Study/JUnit5.drawio.png)
    * Springboot 2.2+ 부터 JUnit5가 기본으로 탑재됩니다.
    * 그림과 같이, JUnit5의 구조로 인해 기존의 JUnit3,4 또한 JUnit5로 실행할 수 있습니다. 
    * 메타 애노테이션을 지원하고 여러 번 중복 사용할 수 있다는 차이점이 있습니다.

<br>

- Mockito
    * 단위 테스트에서 테스트의 의존도를 더 느슨하게 하기 위해 사용했습니다.
    * 구현체가 없이 인터페이스만 존재할 때 테스트를 작성하기 위해 사용했습니다.

<br>

### 💡 Feature List
- 주문하기
    * [X] 메뉴판 정보로 주문
        * [X] 주문 생성
            + [X] 메뉴 찾기
            + [X] 주문서에 주문된 메뉴 찾기
        * [X] 주문 금액 확인
        * [X] 테이블 번호에 해당하는 주문 내역 검색
        * [X] 주문한 정보 보관
    * [X] 테이블 목록에 별도로 표시
    * [X] 추가 주문 시 테이블에서 주문한 수량 확인
    * [X] 주문이 불가능한 경우 이유를 보여주고 재주문 가능

<br>

- 결제하기
    * [X] 주문내역 총합 계산
        * [X] 10마리 이상 시 할인
        * [X] 현금 결제 할인
    * [X] 최종 결제 금액 출력

<br>

- 예측되는 예외 상황
    * [X] 존재하지 않는 테이블 번호 입력
    * [X] 존재하지 않는 메뉴 번호 입력
    * [X] 한 테이블에서 100마리 이상의 주문
    * [X] 주문한 테이블이 테이블 목록에 미표시
    * [X] 마릿수 초과 할인 미적용
    * [X] 현금 결제 할인 미적용
    * [X] 주문, 결제 불가능할 경우 재주문 및 결제 불가능

<br>

### ⌛️ Retrospect

<br>

- **클린코드**
    * '우아한테크코스'에서 제시해준 피드백 내용들을 반영하는 것으로 클린코드가 완성될거라 생각은 하지 않지만, 이들을 기반으로 할 수 있게 메모지에 기록하고 코드를 짜는 중간중간 다시 상기하며 코드를 작성했습니다.
    * 제가 이해한 클린코드의 의의를 간단히 정의하면 협력과 변경의 용이성을 위함이라 생각합니다. 
    * 이 프로젝트는 아주 간단한 콘솔 토이프로젝트이지만, 이 두 가지의 큰 목적을 달성하기 위한 방안이 무엇일지 고민하며, 피드백의 내용들을 공감할 수 있는 프로젝트였습니다.

<br>

- **객체지향 설계**
    * '객체지향 체조 원칙'을 참고하고, 조영호님의 도서들을 기반으로 설계했으나 과연 나의 설계가 올바른 설계인지 의문이 쉽게 지워지지 않았습니다.  
    * 기능 목록을 기준으로 전달할 메시지를 정하고, 메시지의 주체인 객체를 설정하는 순서로 설계를 했으나, 이 설계가 과연 응집도가 높고 의존성이 낮은 변경이 용이한 코드라는 확인되지 않아 그렇다고 생각합니다.
    * 프로그램의 특성에 따라 가상의 상황을 부여하고 그를 토대로 검증하는 방식을 통해 위 사항을 어느 정도 확인할 수 있었습니다.

<br>